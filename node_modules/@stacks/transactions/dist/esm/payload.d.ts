import { IntegerType } from '@stacks/common';
import { BytesReader } from './bytesReader';
import { ClarityValue, OptionalCV } from './clarity/';
import { PrincipalCV } from './clarity/types/principalCV';
import { Address } from './common';
import { ClarityVersion, PayloadType, StacksMessageType } from './constants';
import { LengthPrefixedString } from './postcondition-types';
import { MemoString } from './types';
export type Payload = TokenTransferPayload | ContractCallPayload | SmartContractPayload | VersionedSmartContractPayload | PoisonPayload | CoinbasePayload | CoinbasePayloadToAltRecipient | NakamotoCoinbasePayload | TenureChangePayload;
export declare function isTokenTransferPayload(p: Payload): p is TokenTransferPayload;
export declare function isContractCallPayload(p: Payload): p is ContractCallPayload;
export declare function isSmartContractPayload(p: Payload): p is SmartContractPayload;
export declare function isPoisonPayload(p: Payload): p is PoisonPayload;
export declare function isCoinbasePayload(p: Payload): p is CoinbasePayload;
export interface TokenTransferPayload {
    readonly type: StacksMessageType.Payload;
    readonly payloadType: PayloadType.TokenTransfer;
    readonly recipient: PrincipalCV;
    readonly amount: bigint;
    readonly memo: MemoString;
}
export type PayloadInput = (TokenTransferPayload | (Omit<TokenTransferPayload, 'amount'> & {
    amount: IntegerType;
})) | ContractCallPayload | SmartContractPayload | VersionedSmartContractPayload | PoisonPayload | CoinbasePayload | CoinbasePayloadToAltRecipient | NakamotoCoinbasePayload | TenureChangePayload;
export declare function createTokenTransferPayload(recipient: string | PrincipalCV, amount: IntegerType, memo?: string | MemoString): TokenTransferPayload;
export interface ContractCallPayload {
    readonly type: StacksMessageType.Payload;
    readonly payloadType: PayloadType.ContractCall;
    readonly contractAddress: Address;
    readonly contractName: LengthPrefixedString;
    readonly functionName: LengthPrefixedString;
    readonly functionArgs: ClarityValue[];
}
export declare function createContractCallPayload(contractAddress: string | Address, contractName: string | LengthPrefixedString, functionName: string | LengthPrefixedString, functionArgs: ClarityValue[]): ContractCallPayload;
export interface SmartContractPayload {
    readonly type: StacksMessageType.Payload;
    readonly payloadType: PayloadType.SmartContract;
    readonly contractName: LengthPrefixedString;
    readonly codeBody: LengthPrefixedString;
}
export interface VersionedSmartContractPayload {
    readonly type: StacksMessageType.Payload;
    readonly payloadType: PayloadType.VersionedSmartContract;
    readonly clarityVersion: ClarityVersion;
    readonly contractName: LengthPrefixedString;
    readonly codeBody: LengthPrefixedString;
}
export declare function createSmartContractPayload(contractName: string | LengthPrefixedString, codeBody: string | LengthPrefixedString, clarityVersion?: ClarityVersion): SmartContractPayload | VersionedSmartContractPayload;
export interface PoisonPayload {
    readonly type: StacksMessageType.Payload;
    readonly payloadType: PayloadType.PoisonMicroblock;
}
export declare function createPoisonPayload(): PoisonPayload;
export interface CoinbasePayload {
    readonly type: StacksMessageType.Payload;
    readonly payloadType: PayloadType.Coinbase;
    readonly coinbaseBytes: Uint8Array;
}
export interface CoinbasePayloadToAltRecipient {
    readonly type: StacksMessageType.Payload;
    readonly payloadType: PayloadType.CoinbaseToAltRecipient;
    readonly coinbaseBytes: Uint8Array;
    readonly recipient: PrincipalCV;
}
export declare function createCoinbasePayload(coinbaseBytes: Uint8Array, altRecipient?: PrincipalCV): CoinbasePayload | CoinbasePayloadToAltRecipient;
export interface NakamotoCoinbasePayload {
    readonly type: StacksMessageType.Payload;
    readonly payloadType: PayloadType.NakamotoCoinbase;
    readonly coinbaseBytes: Uint8Array;
    readonly recipient?: PrincipalCV;
    readonly vrfProof: Uint8Array;
}
export declare function createNakamotoCoinbasePayload(coinbaseBytes: Uint8Array, recipient: OptionalCV<PrincipalCV>, vrfProof: Uint8Array): NakamotoCoinbasePayload;
export declare enum TenureChangeCause {
    BlockFound = 0,
    Extended = 1
}
export interface TenureChangePayload {
    readonly type: StacksMessageType.Payload;
    readonly payloadType: PayloadType.TenureChange;
    readonly tenureHash: string;
    readonly previousTenureHash: string;
    readonly burnViewHash: string;
    readonly previousTenureEnd: string;
    readonly previousTenureBlocks: number;
    readonly cause: TenureChangeCause;
    readonly publicKeyHash: string;
}
export declare function createTenureChangePayload(tenureHash: string, previousTenureHash: string, burnViewHash: string, previousTenureEnd: string, previousTenureBlocks: number, cause: TenureChangeCause, publicKeyHash: string): TenureChangePayload;
export declare function serializePayload(payload: PayloadInput): Uint8Array;
export declare function deserializePayload(bytesReader: BytesReader): Payload;
