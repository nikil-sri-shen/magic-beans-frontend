import { IntegerType } from '@stacks/common';
import { Authorization, SpendingConditionOpts } from './authorization';
import { BytesReader } from './bytesReader';
import { AnchorMode, AnchorModeName, AuthType, ChainID, PostConditionMode, TransactionVersion } from './constants';
import { StacksPrivateKey, StacksPublicKey } from './keys';
import { Payload, PayloadInput } from './payload';
import { LengthPrefixedList } from './types';
export declare class StacksTransaction {
    version: TransactionVersion;
    chainId: ChainID;
    auth: Authorization;
    anchorMode: AnchorMode;
    payload: Payload;
    postConditionMode: PostConditionMode;
    postConditions: LengthPrefixedList;
    constructor(version: TransactionVersion, auth: Authorization, payload: PayloadInput, postConditions?: LengthPrefixedList, postConditionMode?: PostConditionMode, anchorMode?: AnchorModeName | AnchorMode, chainId?: ChainID);
    signBegin(): string;
    verifyBegin(): string;
    verifyOrigin(): string;
    signNextOrigin(sigHash: string, privateKey: StacksPrivateKey): string;
    signNextSponsor(sigHash: string, privateKey: StacksPrivateKey): string;
    appendPubkey(publicKey: StacksPublicKey): void;
    signAndAppend(condition: SpendingConditionOpts, curSigHash: string, authType: AuthType, privateKey: StacksPrivateKey): string;
    txid(): string;
    setSponsor(sponsorSpendingCondition: SpendingConditionOpts): void;
    setFee(amount: IntegerType): void;
    setNonce(nonce: IntegerType): void;
    setSponsorNonce(nonce: IntegerType): void;
    serialize(): Uint8Array;
}
export declare function deserializeTransaction(tx: string | Uint8Array | BytesReader): StacksTransaction;
